What we are going to do next is alignment.
I'm going to have a short introduction with a couple of slides.

We have our sequence reads, we did the QC, now we need to know where these reads are coming from the genome. We have a reference genome and we are going to take our short reads and we are going to try and figure out where they come from. What you see here on the slide are a number of reads mapping roughly to the same region. They are not going to match the genome perfectly, we will have sequencing errors, we might have natural variation or SNPs in our individual that are different from the reference genome. Alignment will kind of figure out where is the most likely place of origin for the read in the genome, and then it will also give us a score how likely that is. There are a lot of aligners that map short reads and long reads to references. The ones we commonly use for RNA-seq are STAR or HISAT2. We are going to take our reads, align them to the reference genome and then figure out which genes they come from.

One thing we need to remember about the alignment is that we are aligning reads that originate from mRNA. So, it's entirely possible that some of these reads will span exon junctions. So we need an aligner that is aware that some of these reads when we map them to the reference genome, will have large gaps is them since they span an intron. Like these purple reads in the slide. That's why we have to use specific aligners such as STAR and HISAT2, which are  designed to handle this gapped alignment problem.

Once we do our alignment we will have extra information about each read, we will know which chromomosome they align to, we will know the exact position in that chromosome, we will know if it aligns to positive or negative strand, and we will obtain various quality scores. So we have to have a new format, we can't just append this information to fastq. There is actually a standardized format the aligners store these information and it's called the SAM format. If you are going to deal with a lot aligned data, you will need to be familiar with this format. Generally, we don't look at the SAM file directly, we just use the alignments in this format for downstream analysis. But sometimes when you got a problem in downstream analysis, you might need to go back and check your alignment and try to figure out what went wrong. SAM format contains two main sections: header and alignment section. Header section contains various metadata about the reference genome, about the aligner that has been used to create this file, and what other programmes used to modify the file. Alignment section contains the actual alignments. Unlike the fastq format where we had 4 lines for each read, we have a line for each read with lots of information about the read. If you are dealing with paired data, you will get one line for each pair.

Let's have a look at the simple sam format. This is the header. The first line always starts with @HD, just contains version of sam format specification, and SO which is sorting order of the sam file. We will come to that later on, but there it says unsorted, so this means that reads in the alignment section are in the same order as the fastq file. After HD, you will SQ lines, SQ stands for sequence, and then you got the sequence name, which is the chr1  and LN is the length of that sequence. After these lines you might have other lines depending on the aligner that creates the sam file, but one of the most important ones is the PG line, which stands for the programme. Most of the programmes that create and use sam files add a new line to the header, so you will have a track of what's happened to that file. You can see the ID of the programme, name of the programme and version of the programme. This is very important because as software develops it will change slightly, and when you want to replicate an analysis it's important to use the same version if you want to get exactly the same result. And then we have CL which stands for command line, which shows the exact command that was used to generate this file.

So this was the header, and now we will move on to the alignment section. It might look a bit complex but I will walk you over the most important bits in this format. There is one line per alignment, and each line starts with the read name. After a few columns, you can see the actual sequence which was the second line in the fastq, and right after that you have the base quality scores which was the fourth line in the fastq. So we actually have all the information from fastq file and a number of other fields.

So I took one of these lines and printed out like this to explain some of these fields. It's one line of alignment from SAM file. Read name, sequence and quality lines are there as we have seen in the previous slide, and there are a number of other bits of information here.
So these 9 lines here (or rather columns in SAM file) are obligatory in each sam file. The rest of the fields are optional and aligner dependant. QNAME is read name, I will explain the flag in a minute. RNAME is reference name, and in this case it's 12, meaning the read maps to chr12, POS is the 5' position of the read. Then we have MAPQ which stands for mapping quality score. There is no standard range for this and different aligners use different formats. For RNA-seq aligners report fairly simple scores: one score for a perfect mapping and a couple of other scores for reads mapping to multiple positions in the genome. CIGAR string describes how exactly the read aligns to the genome, it can be very complex and you can read details about CIGAR string in SAM format specification, but here it says that the first 92 bases match perfectly, than there is a gap of 754 bases (indicated with N) and then there are 8 more bases matching perfectly. So out 100bp read aligns perfectly to the genome with a gap, so this read is probably spanning an exon junction. RNEXT and PNEXT are for paired end data. So if you have paired end data, RNEXT will indicate which chromosome the pair is mapping and PNEXT will indicate the exact position. TLEN is also for paired end. With paired-end data, we have more information since we are mapping both ends of the fragment, so we can actually get the total length of the fragment from which the reads originate from. But, with single end data, these information is not there in the SAM file. The other fields are optional and depend on the aligner, generally you don't use them explicitly. They contain information about the read and the mapping, and other tools that work with the SAM file might use these fields.

Let me go back to the flags, this flag is important. Basically, it gives information about the read and its alignment. For instance, if your read is properly aligned, it would have a flag of 2. For instance, the flag for this read is 16, so it means that the read aligns to reverse strand. Things can get a bit complex when multiple of these statements hold true for that read, you basically add them up. Again you won't need to directly interact with these, and the tools that we use will deal with these fields and flags under the hood for us, but it's important for you to know these if you need to investigate problems in your data or analysis.

So, the tool we are going to use for alignment is HISAT2. We chose HISAT2 here since it's a well established method, used widely and quite fast. But you can use other aligners as well, and obtain virtually the same biological results. There is a number of tools that you could use, I personally use STAR since I also use it for my other short read alignment data such as ChIP-seq or ATAC-seq. There is very little difference between these tools, and more importantly, even if there are differences they won't affect the biological conclusions at the end of your experiment.
So with HISAT2 we need to do two things: index the genome and align the reads to the genome. The first step with HISAT2, or with any other aligner, is to index the reference genome. With human genome, we are talking about a sequence of 3 billion bases. It's a massive amount of bases. And you will come with your 100bp read and will search the location of the sequence, you will try to find where this sequence might have come from. It's like looking for a single word in an encyclopaedia, it's probably an outdated analogy, but if you are looking for a word in an encylopedia, you don't go page by page looking for the word - you would go to the index, and see the pages where the word is mentioned. We are going to the same thing with HISAT2: we will index the genome and it will make the alignment much more faster.

In the practical, we are going to do the first step, which is indexing the genome. We actually created the index for the entire genome already, but just for you to see how indexing works, you will create an index for the genome that contains one chromosome. Creating the index for entire genome takes a bit of a time, so instead you will index a subset of the genome and see how that works. And once you see how that works, you will take the fastq file we already looked at for QC and align that with HISAT2 against the entire genome this time. Using the index we created earlier for you. That will generate SAM file, the SAM file I described is a plain text file. So you can open it with any text editor, it's a human readable format. But, we are getting at least 70-80 million reads, and in case of paired end we are looking at 160 million reads. When we align these reads, the SAM files storing the alignment becomes very big, cumbersome and takes a lot storage space. Once we get that SAM file, we'are going to convert it to a so-called BAM file, which is the binary version - compressed version of the SAM file. And we will do that using a tool called samtools. And from then on, we will work with the compressed version, which is easier for software to read and takes up less space on disk. In order to make that easy for access for downstream tools, we are going to index it, pretty much the same way we indexed the genome.

Let's go to the practical. The explanations here will hopefully walk you step by step. I'll give you about half an hour for this part, this is a bit more to do it then fastqc. Please click the YES button if you're finished - some of you might be more experienced in command line & R than others, and pace might be a bit too slow for you; but then we have less experienced people so to keep everyone on the same page let's take about half an hour to do the exercise, and if you're finished early click YES, take a cup of tea and be back here around 12:30. If you're stuck raise your hand and someone will help you, and if you have general questions use the Google Doc.




12:15 - around half an hour?
